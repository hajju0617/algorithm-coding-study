- [소수 찾기](https://school.programmers.co.kr/learn/courses/30/lessons/12921)

```java
public static int solution(int n) {
    boolean[] isNotPrime = new boolean[n + 1];
    isNotPrime[0] = true;  // 0은 소수가 아님
    isNotPrime[1] = true;  // 1은 소수가 아님

    for (int i = 2; i * i <= n; i++) {
        if (!isNotPrime[i]) {
            for (int j = i * i; j <= n; j += i) {
                isNotPrime[j] = true;
            }
        }
    }
}
```

- 주어진 수(n) + 1만큼의 boolean타입 배열을 만듦.
    - boolean타입 배열은 초기값이 `false`임.

- `i * i <= n`의 의미.
  (곱셈을 사용한 이유는 Math.sqrt(n)를 호출하지 않고 비교 연산만으로 성능 최적화함.)
    - 만약 어떤 수 n이 합성수(소수가 아님)라면 항상 두 수의 곱(a * b)으로 표현할 수 있음.
    - 이때 `a ≤ √n 또는 b ≤ √n` 중 하나는 반드시 참임..
        - 따라서 √n까지만 검사하면 그 이후는 이미 앞에서 지워진 배수들이므로 중복됨.
- `왜 a ≤ √n 또는 b ≤ √n 중 하나는 참인가?`
    - 합성수 : 두 개 이상의 수의 곱으로 나타낼 수 있는 수.
        - `Ex)` 6은 `2 * 3`으로 나타낼 수 있으므로 합성수임.
    - `Ex)` n = 36
        - 36은 `2 * 18`, `3 * 12`, `4 * 9`, `6 * 6` 등으로 표현됨.
            - `2 * 18`에서 2는 `√36 = 6`보다 작은 수이고, 18은 그보다 큰 수임.
            - `3 * 12`에서 3은 `√36`보다 작고, 12는 그보다 큼.
            - `6 * 6`에서 두 수는 같음.
        - 즉, 곱셈으로 나타낼 수 있는 수 중 하나는 항상 `√36` 이하이고, 나머지는 그 이상임.
    - `Ex)` n = 100
        - 100은 `2 * 50`, `4 * 25`, `5 * 20`, `10 * 10`으로 나타낼 수 있음.
            - `2 * 50`에서 2는 `√100 = 10`보다 작고, 50은 그보다 큼.
            - `4 * 25`에서 4는 10보다 작고, 25는 그보다 큼.
            - `5 * 20`에서 5는 10보다 작고, 20은 그보다 큼.
            - `10 * 10`에서 두 수는 같음.
        - 따라서 하나의 수가 `√n`보다 작다면, 그 짝은 반드시 `√n`보다 크거나 같음.


- `Ex)` n = 100이면 i ≤ 10까지만 보면 충분함.
    - 즉, 더 이상의 검사는 불필요하므로 반복을 i * i <= n까지로 제한.

- `for (int j = i * i; j <= n; j += i)`
    -  왜 `j = i * i`부터 시작?
    - i가 소수라면, 그 이전의 `i * 2`, `i * 3`, ..., `i * (i - 1)`은 이미 이전 단계에서 다른 소수(i보다 작은 수)에 의해 지워졌음.
    - `Ex)` i = 5일 때
      `5 * 2` = 10, `5 * 3` = 15, ... 등은 이미 i = 2, 3 때 지워졌음.
        - 따라서 중복 제거를 위해 j = i * i부터 시작.
    - 왜 `j += i`인가?
        - i의 배수를 지우기 위해 i씩 증가시켜가며 배열을 방문함.
- `Ex)` n = 30
```
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
```
- 1은 소수가 아니므로 제외.
- i = 2 → 지우는 수: 4, 6, 8, ..., 30
```
2 3 X 5 X 7 X 9 X 11 X 13 X 15 X 17 X 19 X 21 X 23 X 25 X 27 X 29 X
```
- i = 3 → 지우는 수: 9, 12, 15, ..., 30
```
2 3 X 5 X 7 X X X 11 X 13 X X X 17 X 19 X X X 23 X 25 X X X 29 X
```
- i = 4는 이미 지워졌으므로 i = 5 → 시작은 25부터: 25, 30
  (10, 15, 20 등은 이미 앞에서 지워짐)
```
2 3 X 5 X 7 X X X 11 X 13 X X X 17 X 19 X X X 23 X X X X X 29 X
```
- 최종 남은 수는 소수.
```
3 5 7 11 13 17 19 23 29
```